---
marp: true
theme: default
paginate: true
style: |
  section {
    font-size: 28px;
  }
  code {
    font-size: 0.9em;
  }
  h1 {
    font-size: 2em;
    color: #2c3e50;
  }
  h2 {
    font-size: 1.5em;
    color: #3498db;
  }
  h3 {
    font-size: 1.2em;
    color: #2980b9;
  }
  img {
    max-width: 90%;
    max-height: 70vh;
    object-fit: contain;
    margin: 0 auto;
    display: block;
  }
---

# Vue.js Options APIの課題と<br>Composition APIのメリット
---

## 1. はじめに

- 前職でVue2のOptions APIを使っていた
- Vue3でComposition APIが推される理由が気になった
- 今回は「なぜ変わったのか？」を整理して共有します

---

## 2. Options APIとは

- Vue2から使われている従来のコンポーネント定義方法
- `data`, `methods`, `computed`などのオプションで構成

```javascript
export default {
  data() { return { count: 0 } },
  methods: {
    increment() { this.count++ }
  },
  computed: {
    doubled() { return this.count * 2 }
  }
}
```

---

## 3. Composition APIとは

- Vue3で導入された新しいコンポーネント定義方法
- `ref`や`reactive`を利用し、ロジックをまとめて書ける

```javascript
import { ref, computed } from 'vue'

const count = ref(0)
const doubled = computed(() => count.value * 2)
function increment() { count.value++ }
```
---

## 4. Options APIの課題

- コードが散在しやすい
- 機能の再利用が難しい
- TypeScriptとの相性が悪い

---

## 課題1: コードが散在する

- 同じ機能に関するコードがdata, methods, computedなどに分散
- ロジックを理解・修正する時にあちこち探す必要がある

![1746780435110](image/20250509-lt/1746780435110.png)

---

## 解決1: コードをまとめて書ける

- Composition APIなら関連ロジックをsetup関数内にまとめて書ける
- 理解や修正が楽になる

![1746937426026](image/2025-05-11-lt/1746937426026.png)

---

## 課題2: 機能の再利用が難しい

- ユーティリティ関数：状態（data）の共有ができない
- ミックスイン：名前の衝突や、どのミックスインが何を提供しているか分かりづらい
- 特にミックスインは複雑化しやすく、保守が大変

---

## 解決2: 機能の再利用が簡単

- コンポーザブル関数として状態とロジックをセットで切り出せる
- 再利用しやすく、名前の衝突も回避できる

```javascript
import { useValidation } from './useValidation'

...
const { value, error, validateEmail } = useValidation()
```

---

## 課題3: TypeScriptとの相性が悪い

- Options APIでTypeScriptを使うと型定義が煩雑
- 大きなコンポーネントだとコストが高い

```typescript
interface ComponentData { user: { name: string; email: string; } }
interface ComponentMethods { updateUser(name: string): void; }

export default Vue.extend({
  data(): ComponentData {
    return { user: { name: '', email: '' } }
  },
  methods: {
    updateUser(newName: string) {
      this.user.name = newName;
    }
  }
});
```

---

## 解決3: TypeScriptとの相性が良い

- Composition APIは標準的なTypeScript機能がそのまま使える
- 型推論も効く

```typescript
import { ref, Ref } from 'vue'
...
const count: Ref<number> = ref(0)
```

---

## まとめ

- 関連ロジックを直感的にまとめやすくなった
- 状態とロジックの再利用がよりシンプルに
- TypeScriptがより自然に使える


---

# ご清聴ありがとうございました！
